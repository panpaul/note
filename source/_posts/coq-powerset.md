---
title: 使用Coq求一个集合的所有子集
date: 2020-04-12 10:50:53
updated: 2020-04-13 15:40:00
tags: Coq
mathjax: true
---

最近离散数学在讲集合，刚好作业里有一个使用`Coq`求子集的题目，感觉比较有意思就记录一下：

<!--more-->

对于一个集合`[1;2;3]`，它的所有子集组成的集合应该是

> [ [ ] ; [1] ; [2] ; [3] ; [ 1 ; 2 ] ; [ 1 ; 3 ] ; [ 2 ; 3 ] ; [ 1 ; 2 ; 3 ] ]

共 $2^n$ 个元素。

现在考虑如何构造这样一个子集的集合。

根据离散数学老师经常提及的一个词**归纳定义**，我们大致可以总结出这样的一个归纳条件：

1. 如果输入的集合为空集，那么空集的子集构成的集合是`[[]]`（归纳基础）
2. 如果不为空，那么从该集合中提取出一个元素，并递归求出由剩下的元素子集构成的集合，然后把这个集合复制一次，向其中一个所有元素插入之前提取出来的元素。

这里举一个例子：求集合`[1;2]`所有子集组成的集合：

1. 输入集合`[1;2]`：符合第2点条件，提出元素`1`，剩下的是`[2]`
2. 输入集合`[2]`：符合第2点条件，提出元素`2`，剩下的是`[]`
3. 输入集合`[]`：符合第1点条件，返回`[[]]`
4. 回到步骤2，把这个集合复制一次得到`[[];[]]`，向其中一个插入提取出的元素`2`，得到`[[2];[]]`
5. 回到步骤1，把这个集合复制一次得到`[[2];[];[2];[]]`，向其中一个插入提取出的元素`1`，得到`[[2;1];[1];[2];[]]`
6. 结束，整理一下就是`[[];[1];[2];[1;2]]`

然后考虑使用`Coq`来实现这样一个递归过程：

```coq
Require Import List.
Import ListNotations.

(* 先做一些定义 *)
Definition NatSet := list nat.
Definition Add n s : NatSet := n :: s.

(* 
	构造一个赋值函数map
	用于对集合中的每个元素执行映射操作
*)
Fixpoint map {A B: Set} (f : A -> B) l :=
  match l with
  | [] => []
  | n :: l' => (f n) :: map f l'
  end.

Compute map S [1;2;3;4].
(*
     = [2; 3; 4; 5]
     : list nat
*)

(* 要实现的递归函数 *)
Fixpoint powerset l : list NatSet :=
  match l with
  | [] => [[]] (* 第一点条件 *)
  | n :: l' => let s := powerset l' in
               (map (Add n) s) ++ s (* 第二点条件 *)
  end.

Compute powerset [1;2;3;4].
(*
     = [[1; 2; 3; 4]; [1; 2; 3]; [1; 2; 4]; [1; 2]; [1; 3; 4]; [1; 3]; 
       [1; 4]; [1]; [2; 3; 4]; [2; 3]; [2; 4]; [2]; [3; 4]; [3]; [4]; []]
     : list NatSet
*)
```

